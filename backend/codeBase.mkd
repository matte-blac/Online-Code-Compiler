App.js

import axios from "axios";
import "./App.css";
import React, { useState } from "react";

function App() {
const [code, setCode] = useState("");
const [language, setLanguage] = useState("cpp");
const [output, setOutput] = useState("");

const handleSubmit = async () => {
const payload = {
language,
code,
};
try {
const { data } = await axios.post("http://localhost:5000/run", payload);
setOutput(data.output);
} catch (err) {
console.log(err.response);
}
};

return (

<div className="App">
<h1>Online Code Compiler</h1>
<div>
<label>Language: </label>
<select
value={language}
onChange={(e) => {
setLanguage(e.target.value);
console.log(e.target.value);
}} >
<option value="cpp">C++</option>
<option value="py">Python</option>
</select>
</div>
<br />
<textarea
rows="20"
cols="75"
value={code}
onChange={(e) => {
setCode(e.target.value);
}} ></textarea>
<br />
<button onClick={handleSubmit}>Submit</button>
<p>{output}</p>
</div>
);
}

export default App;

script.js

const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");

const { generateFile } = require("./generateFile");
const { executeCpp } = require("./executeCpp");
const { executePy } = require("./executePy");
const Job = require("./models/Job");

main().catch((err) => console.log(err));

async function main() {
await mongoose.connect(
"mongodb://127.0.0.1:27017/compilerapp",
console.log("Successfully connected to database")
);
}

const app = express();

app.use(cors());
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.get("/", (req, res) => {
return res.json({ hello: "world!" });
});

app.post("/run", async (req, res) => {
const { language = "cpp", code } = req.body;
console.log(language, code.length);

if (code === undefined) {
return res.status(400).json({ success: false, error: "Empty Code Body!" });
}

try {
// generate a c++ file with content from the request
const filepath = await Promise.race([
generateFile(language, code),
new Promise((_, reject) =>
setTimeout(() => reject("File generation timed out"), 5000)
),
]);

    const job = await new Job({ language, file }).save();

    console.log(job);

    // run the file and send the response
    let output;

    if (language === "cpp") {
      output = await Promise.race([
        executeCpp(filepath),
        new Promise((_, reject) =>
          setTimeout(() => reject("Execution timed out"), 5000)
        ),
      ]);
    } else {
      output = await Promise.race([
        executePy(filepath),
        new Promise((_, reject) =>
          setTimeout(() => reject("Execution timed out"), 5000)
        ),
      ]);
    }

    return res.json({ filepath, output });

} catch (err) {
return res.status(500).json({ err });
}
});

app.listen(5000, () => {
console.log("Listening on port 5000!");
});

executeCpp.js

const { exec } = require("child_process");
const fs = require("fs");
const path = require("path");

const outputPath = path.join(\_\_dirname, "outputs");

if (!fs.existsSync(outputPath)) {
fs.mkdirSync(outputPath, { recursive: true });
}

const executeCpp = (filepath) => {
const jobId = path.basename(filepath).split(".")[0];
const outPath = path.join(outputPath, `${jobId}.out`);

return new Promise((resolve, reject) => {
exec(
`g++ "${filepath}" -o "${outPath}" && cd "${outputPath}" && "./${jobId}.out"`,
(error, stdout, stderr) => {
if (error || stderr) {
reject({ error, stderr });
} else {
resolve(stdout);
}
}
);

    setTimeout(() => {
      reject("Execution timed out");
    }, 5000);

});
};

module.exports = {
executeCpp,
};

executePy.js

const { exec } = require("child_process");

const executePy = (filepath) => {
return new Promise((resolve, reject) => {
exec(`python "${filepath}"`, (error, stdout, stderr) => {
if (error || stderr) {
reject({ error, stderr });
} else {
resolve(stdout);
}
});

    setTimeout(() => {
      reject("Execution timed out");
    }, 5000);

});
};

module.exports = {
executePy,
};

generateFile.js

const { rejects } = require("assert");
const fs = require("fs");
const { resolve } = require("path");
const path = require("path");
const { v4: uuid } = require("uuid");

const dirCodes = path.join(\_\_dirname, "codes");

if (!fs.existsSync(dirCodes)) {
fs.mkdirSync(dirCodes, { recursive: true });
}

const generateFile = async (format, content) => {
const jobID = uuid(); // create a unique path
const fileName = `${jobID}.${format}`; // join the format with it
const filepath = path.join(dirCodes, fileName); //create a file path

return Promise.race([
new Promise((resolve) => {
fs.writeFileSync(filepath, content); //write the content in that file
resolve(filepath);
}),
new Promise((_, reject) =>
setTimeout(() => reject("File write timed out"), 5000)
),
]);
};

module.exports = {
generateFile,
};

Job.js

const mongoose = require("mongoose");

const JobSchema = mongoose.Schema({
language: {
type: String,
required: true,
enum: ["cpp", "py"],
},
filepath: {
type: String,
required: true,
},
SubmittedAt: {
type: Date,
default: Date.now,
},
startedAt: {
type: Date,
},
completedAt: {
type: Date,
},
output: {
type: String,
default: "pending",
enum: ["pending", "sunccess", "error"],
},
});

const Job = new mongoose.model("job", JobSchema);

module.exports = Job;
